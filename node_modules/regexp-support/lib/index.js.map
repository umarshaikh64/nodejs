{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Created by user on 2018/4/26/026.\n */\n\nimport FlagsName, { FlagsPattern, IFlagsPatternTestFn } from './flags';\n\nexport { FlagsName }\n\ntype valueof<T> = T[keyof T];\n\n/**\n * Check whether a RegExp flag is supported\n */\nexport function hasSupportFlag(flag: string, RegExpClass: typeof RegExp = RegExp, skipPatternCheck?: boolean)\n{\n\tif (!flag || typeof flag != 'string' || flag.length != 1)\n\t{\n\t\tthrow new TypeError(`\"${flag}\" not a valid flag`)\n\t}\n\n\tlet isSupported: boolean = null;\n\ttry\n\t{\n\t\tif (!skipPatternCheck && FlagsPattern[flag])\n\t\t{\n\t\t\tisSupported = testFlag(flag, RegExpClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnew RegExpClass('', flag);\n\t\t\tisSupported = true;\n\t\t}\n\t}\n\tcatch (exception)\n\t{\n\t\tisSupported = false;\n\t}\n\treturn isSupported;\n}\n\nexport function testFlag(flag: string, RegExpClass?: typeof RegExp, testPattern?: typeof FlagsPattern): boolean\nexport function testFlag(flag: string, RegExpClass?: ICreateRegExp, testPattern?: typeof FlagsPattern): boolean\nexport function testFlag<T>(flag: string,\n\t// @ts-ignore\n\tRegExpClass: ITypeCreateRegExp<T> = RegExp,\n\ttestPattern = FlagsPattern\n): boolean\n{\n\tif (testPattern[flag] && testPattern[flag].length)\n\t{\n\t\treturn testPattern[flag].every(function (v)\n\t\t{\n\t\t\tlet [pattern, input, value, fn] = v;\n\t\t\tlet bool: boolean;\n\n\t\t\tlet r = createRegExp(pattern, flag, RegExpClass);\n\n\t\t\tif (fn)\n\t\t\t{\n\t\t\t\tif (typeof fn == 'function')\n\t\t\t\t{\n\t\t\t\t\tbool = (fn as IFlagsPatternTestFn)(r, value, input, pattern, RegExpClass, flag);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool = r[fn](input) === value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool = r.test(input) === value;\n\t\t\t}\n\n\t\t\treturn bool;\n\t\t}) === true;\n\t}\n\n\treturn false;\n}\n\nimport { PatternTest } from './pattern';\n\nexport function testFlagsAll(RegExpClass: typeof RegExp = RegExp, skipPatternCheck?: boolean): {\n\tg: boolean,\n\ti: boolean,\n\tm: boolean,\n\ts: boolean,\n\tu: boolean,\n\ty: boolean,\n\n\t[key: string]: boolean\n}\n{\n\tlet flagsAll = {} as IFlagsAll;\n\n\tfor (let i = 65; i <= 90; i++)\n\t{\n\t\tlet k1 = String.fromCharCode(i);\n\t\tlet k2 = String.fromCharCode(i + 32);\n\n\t\tflagsAll[k1] = hasSupportFlag(k1, RegExpClass, skipPatternCheck);\n\n\t\tflagsAll[k2] = hasSupportFlag(k2, RegExpClass, skipPatternCheck);\n\t}\n\n\tlet def = [\n\t\t'g',\n\t\t'i',\n\t\t'm',\n\t\t's',\n\t\t'u',\n\t\t'y',\n\t];\n\n\tflagsAll = Object.keys(flagsAll).sort().reduce(function (a, flag)\n\t{\n\t\tif (flagsAll[flag] || def.includes(flag))\n\t\t{\n\t\t\ta[flag] = flagsAll[flag];\n\t\t}\n\n\t\treturn a;\n\t}, {} as IFlagsAll);\n\n\treturn flagsAll;\n}\n\nexport interface IFlagsAll\n{\n\tg: boolean,\n\ti: boolean,\n\tm: boolean,\n\ts: boolean,\n\tu: boolean,\n\ty: boolean,\n\n\t[key: string]: boolean\n}\n\nexport interface ICreateRegExp\n{\n\tcreate?(pattern, flag)\n\n\tcreate?(pattern, flag?)\n\n\tcreate?(pattern, flag?, ...argv)\n}\n\nexport type ITypeCreateRegExp<T> =\n\tT extends typeof RegExp ? typeof RegExp :\n\t\tT extends ICreateRegExp ? ICreateRegExp :\n\t\t\t//T extends RegExpConstructor ? RegExpConstructor :\n\t\t\tany\n\t;\n\n// @ts-ignore\nexport function createRegExp<T>(pattern: string, flag?: string, RegExpClass: ITypeCreateRegExp<T> = RegExp)\n{\n\tlet r: RegExp;\n\n\tif (typeof (<ICreateRegExp>RegExpClass).create == 'function')\n\t{\n\t\tr = (<ICreateRegExp>RegExpClass).create(pattern, flag);\n\t}\n\telse\n\t{\n\t\tr = new (<typeof RegExp>RegExpClass)(pattern, flag);\n\t}\n\n\treturn r;\n}\n"]}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isMergeableObject = require("is-mergeable-object");
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, optionsArgument, tmp) {
    let clone = !optionsArgument || optionsArgument.clone !== false;
    let bool = clone && _isMergeableObject(value, optionsArgument, tmp);
    let ret = (bool)
        ? deepmerge(emptyTarget(value), value, optionsArgument)
        : value;
    if (optionsArgument && optionsArgument.keyValueOrMode && !bool && tmp && ('key' in tmp)) {
        if (tmp.destination) {
            //console.log('destination', tmp.destination[tmp.key], ret, tmp.key);
            ret = tmp.destination[tmp.key] || ret;
        }
        if (tmp.target) {
            //console.log('target', tmp.target[tmp.key], ret, tmp.key);
            ret = tmp.target[tmp.key] || ret;
        }
        if (tmp.source) {
            //console.log('source', tmp.source[tmp.key], ret, tmp.key);
            ret = tmp.source[tmp.key] || ret;
        }
    }
    return ret;
}
function _isMergeableObject(value, optionsArgument, tmp) {
    let ret;
    if (optionsArgument && optionsArgument.isMergeableObject) {
        ret = optionsArgument.isMergeableObject(value, isMergeableObject, optionsArgument, tmp);
    }
    if (ret === null || typeof ret === 'undefined') {
        if (value && (typeof value[deepmerge.SYMBOL_IS_MERGEABLE] == 'boolean')) {
            ret = value[deepmerge.SYMBOL_IS_MERGEABLE];
        }
        else {
            ret = isMergeableObject(value);
        }
    }
    return ret;
}
function defaultArrayMerge(target, source, optionsArgument) {
    return target.concat(source).map(function (element, index, array) {
        return cloneUnlessOtherwiseSpecified(element, optionsArgument, {
            key: index,
        });
    });
}
function mergeObject(target, source, optionsArgument) {
    let destination = {};
    if (_isMergeableObject(target, optionsArgument)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument, {
                key,
                source,
                target,
                destination,
            });
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!_isMergeableObject(source[key], optionsArgument, {
            key,
            source,
            target,
        }) || !target[key]) {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument, {
                key,
                source,
                target,
            });
        }
        else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination;
}
function deepmerge(target, source, optionsArgument) {
    let sourceIsArray = Array.isArray(source);
    let targetIsArray = Array.isArray(target);
    let options = optionsArgument || { arrayMerge: defaultArrayMerge };
    let sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, optionsArgument, {
            target,
            source,
        });
    }
    else if (sourceIsArray) {
        let arrayMerge = options.arrayMerge || defaultArrayMerge;
        return arrayMerge(target, source, optionsArgument);
    }
    else {
        return mergeObject(target, source, optionsArgument);
    }
}
exports.deepmerge = deepmerge;
(function (deepmerge) {
    deepmerge.isMergeable = isMergeableObject;
    deepmerge.SYMBOL_IS_MERGEABLE = Symbol.for('SYMBOL_IS_MERGEABLE');
    deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array)) {
            throw new Error('first argument should be an array');
        }
        // @ts-ignore
        return array.reduce(function (prev, next) {
            return deepmerge(prev, next, optionsArgument);
        }, {});
    };
})(deepmerge || (deepmerge = {}));
exports.deepmerge = deepmerge;
deepmerge.deepmerge = deepmerge;
deepmerge.default = deepmerge;
exports.default = deepmerge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5REFBMEQ7QUFFMUQsU0FBUyxXQUFXLENBQUMsR0FBRztJQUV2QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO0FBQ3BDLENBQUM7QUFFRCxTQUFTLDZCQUE2QixDQUFDLEtBQUssRUFBRSxlQUFrQyxFQUFFLEdBQXNCO0lBRXZHLElBQUksS0FBSyxHQUFHLENBQUMsZUFBZSxJQUFJLGVBQWUsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDO0lBRWhFLElBQUksSUFBSSxHQUFHLEtBQUssSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRXBFLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ2YsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLGVBQWUsQ0FBQztRQUN2RCxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRVQsSUFBSSxlQUFlLElBQUksZUFBZSxDQUFDLGNBQWMsSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksR0FBRyxDQUFDLEVBQ3ZGO1FBQ0MsSUFBSSxHQUFHLENBQUMsV0FBVyxFQUNuQjtZQUNDLHFFQUFxRTtZQUNyRSxHQUFHLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxHQUFHLENBQUMsTUFBTSxFQUNkO1lBQ0MsMkRBQTJEO1lBQzNELEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUM7U0FDakM7UUFFRCxJQUFJLEdB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RUFBRSxDQUFDLENBQUE7SUFDUCxDQUFDLENBQUE7QUFDRixDQUFDLEVBMUNTLFNBQVMsS0FBVCxTQUFTLFFBMENsQjtBQUtRLDhCQUFTO0FBSGxCLFNBQVMsQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQ2hDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBSTlCLGtCQUFlLFNBQVMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc01lcmdlYWJsZU9iamVjdCA9IHJlcXVpcmUoJ2lzLW1lcmdlYWJsZS1vYmplY3QnKTtcblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKVxue1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9uc0FyZ3VtZW50OiBkZWVwbWVyZ2UuT3B0aW9ucywgdG1wPzogZGVlcG1lcmdlLklDYWNoZSlcbntcblx0bGV0IGNsb25lID0gIW9wdGlvbnNBcmd1bWVudCB8fCBvcHRpb25zQXJndW1lbnQuY2xvbmUgIT09IGZhbHNlO1xuXG5cdGxldCBib29sID0gY2xvbmUgJiYgX2lzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlLCBvcHRpb25zQXJndW1lbnQsIHRtcCk7XG5cblx0bGV0IHJldCA9IChib29sKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnNBcmd1bWVudClcblx0XHQ6IHZhbHVlO1xuXG5cdGlmIChvcHRpb25zQXJndW1lbnQgJiYgb3B0aW9uc0FyZ3VtZW50LmtleVZhbHVlT3JNb2RlICYmICFib29sICYmIHRtcCAmJiAoJ2tleScgaW4gdG1wKSlcblx0e1xuXHRcdGlmICh0bXAuZGVzdGluYXRpb24pXG5cdFx0e1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnZGVzdGluYXRpb24nLCB0bXAuZGVzdGluYXRpb25bdG1wLmtleV0sIHJldCwgdG1wLmtleSk7XG5cdFx0XHRyZXQgPSB0bXAuZGVzdGluYXRpb25bdG1wLmtleV0gfHwgcmV0O1xuXHRcdH1cblxuXHRcdGlmICh0bXAudGFyZ2V0KVxuXHRcdHtcblx0XHRcdC8vY29uc29sZS5sb2coJ3RhcmdldCcsIHRtcC50YXJnZXRbdG1wLmtleV0sIHJldCwgdG1wLmtleSk7XG5cdFx0XHRyZXQgPSB0bXAudGFyZ2V0W3RtcC5rZXldIHx8IHJldDtcblx0XHR9XG5cblx0XHRpZiAodG1wLnNvdXJjZSlcblx0XHR7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdzb3VyY2UnLCB0bXAuc291cmNlW3RtcC5rZXldLCByZXQsIHRtcC5rZXkpO1xuXHRcdFx0cmV0ID0gdG1wLnNvdXJjZVt0bXAua2V5XSB8fCByZXQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gX2lzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlLCBvcHRpb25zQXJndW1lbnQ6IGRlZXBtZXJnZS5PcHRpb25zLCB0bXA/OiBkZWVwbWVyZ2UuSUNhY2hlKVxue1xuXHRsZXQgcmV0O1xuXHRpZiAob3B0aW9uc0FyZ3VtZW50ICYmIG9wdGlvbnNBcmd1bWVudC5pc01lcmdlYWJsZU9iamVjdClcblx0e1xuXHRcdHJldCA9IG9wdGlvbnNBcmd1bWVudC5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSwgaXNNZXJnZWFibGVPYmplY3QsIG9wdGlvbnNBcmd1bWVudCwgdG1wKVxuXHR9XG5cdGlmIChyZXQgPT09IG51bGwgfHwgdHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpXG5cdHtcblx0XHRpZiAodmFsdWUgJiYgKHR5cGVvZiB2YWx1ZVtkZWVwbWVyZ2UuU1lNQk9MX0lTX01FUkdFQUJMRV0gPT0gJ2Jvb2xlYW4nKSlcblx0XHR7XG5cdFx0XHRyZXQgPSB2YWx1ZVtkZWVwbWVyZ2UuU1lNQk9MX0lTX01FUkdFQUJMRV07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRyZXQgPSBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudDogZGVlcG1lcmdlLk9wdGlvbnMpXG57XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpXG5cdHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9uc0FyZ3VtZW50LCB7XG5cdFx0XHRrZXk6IGluZGV4LFxuXHRcdH0pXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQ6IGRlZXBtZXJnZS5PcHRpb25zKVxue1xuXHRsZXQgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKF9pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnNBcmd1bWVudCkpXG5cdHtcblx0XHRPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSlcblx0XHR7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnNBcmd1bWVudCwge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHNvdXJjZSxcblx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRkZXN0aW5hdGlvbixcblx0XHRcdH0pXG5cdFx0fSlcblx0fVxuXHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSlcblx0e1xuXHRcdGlmICghX2lzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldLCBvcHRpb25zQXJndW1lbnQsIHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRzb3VyY2UsXG5cdFx0XHRcdHRhcmdldCxcblx0XHRcdH0pIHx8ICF0YXJnZXRba2V5XSlcblx0XHR7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnNBcmd1bWVudCwge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHNvdXJjZSxcblx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0fSlcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zQXJndW1lbnQpXG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZTxUMSwgVDI+KHg6IFQxLCB5OiBUMiwgb3B0aW9ucz86IGRlZXBtZXJnZS5PcHRpb25zKTogUGFydGlhbDxUMSAmIFQyPlxuZnVuY3Rpb24gZGVlcG1lcmdlPFQ+KHg6IFBhcnRpYWw8VD4sIHk6IFBhcnRpYWw8VD4sIG9wdGlvbnM/OiBkZWVwbWVyZ2UuT3B0aW9ucyk6IFBhcnRpYWw8VD5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KVxue1xuXHRsZXQgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0bGV0IHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdGxldCBvcHRpb25zID0gb3B0aW9uc0FyZ3VtZW50IHx8IHsgYXJyYXlNZXJnZTogZGVmYXVsdEFycmF5TWVyZ2UgfTtcblx0bGV0IHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaClcblx0e1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCwge1xuXHRcdFx0dGFyZ2V0LFxuXHRcdFx0c291cmNlLFxuXHRcdH0pO1xuXHR9XG5cdGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpXG5cdHtcblx0XHRsZXQgYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0XHRyZXR1cm4gYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCk7XG5cdH1cbn1cblxubmFtZXNwYWNlIGRlZXBtZXJnZVxue1xuXHRleHBvcnQgaW50ZXJmYWNlIElDYWNoZVxuXHR7XG5cdFx0a2V5P1xuXHRcdHNvdXJjZT9cblx0XHR0YXJnZXQ/XG5cdFx0ZGVzdGluYXRpb24/XG5cdH1cblxuXHRleHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNcblx0e1xuXHRcdGNsb25lPzogYm9vbGVhbjtcblxuXHRcdGFycmF5TWVyZ2U/KGRlc3RpbmF0aW9uOiBhbnlbXSwgc291cmNlOiBhbnlbXSwgb3B0aW9ucz86IE9wdGlvbnMpOiBhbnlbXTtcblxuXHRcdGlzTWVyZ2VhYmxlT2JqZWN0Pyh2YWx1ZSwgaXNNZXJnZWFibGVPYmplY3Q6ICh2YWx1ZSkgPT4gYm9vbGVhbiwgb3B0aW9uc0FyZ3VtZW50PzogT3B0aW9ucywga2V5Pyk6IHZvaWQ7XG5cblx0XHRpc01lcmdlYWJsZU9iamVjdD8odmFsdWUsIGlzTWVyZ2VhYmxlT2JqZWN0OiAodmFsdWUpID0+IGJvb2xlYW4sIG9wdGlvbnNBcmd1bWVudD86IE9wdGlvbnMsIGtleT8pOiBib29sZWFuO1xuXG5cdFx0LyoqXG5cdFx0ICogKHZhbCA9IG9sZCB8fCBuZXcpIG1vZGVcblx0XHQgKi9cblx0XHRrZXlWYWx1ZU9yTW9kZT86IGJvb2xlYW4sXG5cdH1cblxuXHRleHBvcnQgY29uc3QgaXNNZXJnZWFibGU6ICh2YWx1ZSkgPT4gYm9vbGVhbiA9IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHRleHBvcnQgY29uc3QgU1lNQk9MX0lTX01FUkdFQUJMRSA9IFN5bWJvbC5mb3IoJ1NZTUJPTF9JU19NRVJHRUFCTEUnKTtcblxuXHRleHBvcnQgY29uc3QgYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsPFQsIFQyID0gYW55PihhcnJheTogQXJyYXk8UGFydGlhbDxUMiAmIFQ+Piwgb3B0aW9uc0FyZ3VtZW50PzogT3B0aW9ucyk6IFQyICYgVFxuXHRcdHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKVxuXHRcdHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0XHR9XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dClcblx0XHR7XG5cdFx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnNBcmd1bWVudClcblx0XHR9LCB7fSlcblx0fVxufVxuXG5kZWVwbWVyZ2UuZGVlcG1lcmdlID0gZGVlcG1lcmdlO1xuZGVlcG1lcmdlLmRlZmF1bHQgPSBkZWVwbWVyZ2U7XG5cbmV4cG9ydCB7IGRlZXBtZXJnZSB9XG5cbmV4cG9ydCBkZWZhdWx0IGRlZXBtZXJnZVxuXG5kZWNsYXJlIGdsb2JhbFxue1xuXHRpbnRlcmZhY2UgV2luZG93XG5cdHtcblx0XHRkZWVwbWVyZ2U8VD4oeDogUGFydGlhbDxUPiwgeTogUGFydGlhbDxUPiwgb3B0aW9ucz86IGRlZXBtZXJnZS5PcHRpb25zKTogVDtcblxuXHRcdGRlZXBtZXJnZTxUMSwgVDI+KHg6IFQxLCB5OiBUMiwgb3B0aW9ucz86IGRlZXBtZXJnZS5PcHRpb25zKTogVDEgJiBUMjtcblx0fVxufVxuIl19